{
  generate=[psi="yes"]
  classHeader="/* Copyright Niclas Hedhman, 2020. All rights reserved. Licensed under the Apache License, Version 2.0 (the \"License\"). See LICENSE.txt*/"
  parserClass="org.hedhman.pony.idea.generated.parsing.PonyParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
//  elementTypeFactory="org.hedhman.pony.idea.parsing.PonyParserDefinition.createType"
//  tokenTypeFactory="org.hedhman.pony.idea.parsing.PonyParserDefinition.createTokenType"
  elementTypeHolderClass="org.hedhman.pony.idea.generated.parsing.PonyTypes"
  parserUtilClass="com.intellij.lang.parser.GeneratedParserUtilBase"

  psiClassPrefix="Pony"
  psiImplClassSuffix="Impl"
  psiPackage="org.hedhman.pony.idea.generated.psi"
  psiImplPackage="org.hedhman.pony.idea.generated.psi.impl"

  elementTypeClass="org.hedhman.pony.idea.psi.PonyElementType"
  tokenTypeClass="org.hedhman.pony.idea.psi.PonyTokenType"

  tokens=[
      // KEYWORDS
      THIS='this'
      FUN='fun'
      BE='be'
      NEW='new'
      USE='use'
      RETURN='return'
      BREAK='break'
      CONTINUE='continue'
      TYPE='type'
      CLASS='class'
      INTERFACE='interface'
      TRAIT='trait'
      OBJECT='object'
      ERROR='error'
      COMPILE_INTRINSIC='compile_intrinsic'
      PRIMITIVE='primitive'
      ACTOR='actor'
      STRUCT='struct'
      IS='is'
      ISNT='isnt'
      VAR='var'
      LET='let'
      EMBED='embed'
      WHERE='where'
      FFI_CHAR='@'
      COMPILE_ERROR='compile_error'
      AS='as'
      AND='and'
      OR='or'
      XOR='xor'
      NOT='not'
      ADDRESSOF='addressof'
      DIGESTOF='digestof'
      IF='if'
      IFDEF='ifdef'
      IFTYPE='iftype'
      MATCH='match'
      WHILE='while'
      REPEAT='repeat'
      FOR='for'
      WITH='with'
      DO='do'
      UNTIL='until'
      IN='in'
      END='end'
      IF='if'
      ELSE='else'
      ELSEIF='elseif'
      THEN='then'
      TRY='try'
      RECOVER='recover'
      CONSUME='consume'
      HASH='#'
      HASH_READ='#read'
      HASH_SEND='#send'
      HASH_SHARE='#share'
      HASH_ALIAS='#alias'
      HASH_ANY='#any'
      ISO='iso'
      TRN='trn'
      REF='ref'
      VAL='val'
      BOX='box'
      TAG='tag'
      LOC='__loc'

      // NUMBERS & STRING
      TRUE='true'
      FALSE='false'
      NUMBER='regexp:\d+'
      FLOAT='regexp:\d+(\.\d*)?(E|e\d+)?'
      STRING="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"

      // IDENTIFIERS
      SPACE='regexp:\s+'
      WHITE_SPACE='regexp:\s+'
      COMMENT='regexp:(/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+/)|(//.*)'
      ID="regexp:(_|\p{Alpha})(_|'|\w)*"

      // NEWLINE + OPERATOR
      LPAREN_NEW="regexp:(\r|\n|\r\n) \("
      LSQUARE_NEW="regexp:(\r|\n|\r\n) \["
      MINUS_NEW="regexp:(\r|\n|\r\n) -"
      MINUS_TILDE_NEW="regexp:(\r|\n|\r\n) -\~"
  ]
}

module ::= doc_string? use* class_def*;

use ::= ('use' (ID '=')? (STRING | use_ffi) ('if' infix)?);

use_ffi ::= ffi_decl typeargs ('(' | LPAREN_NEW) params? ')' '?'?;

class_def ::= (TYPE | INTERFACE | TRAIT | PRIMITIVE | STRUCT | CLASS | ACTOR ) ('\' ID (',' ID)* '\')? '@'? cap? ID typeparams? (IS type)? doc_string? members;

members ::= field* method*;

field ::= (VAR | LET | EMBED) ID ':' type ('=' infix)? doc_string?;

method ::= (FUN | BE | NEW) ('\' ID (',' ID)* '\')? (cap | FFI_CHAR)? ID typeparams? ('(' | LPAREN_NEW) params? ')' (':' type)? '?'? doc_string? ('=>' rawseq)? ;

annotatedrawseq ::= ('\' ID (',' ID)* '\')? (exprseq | jump);

rawseq ::= exprseq | jump;

exprseq ::= assignment (semiexpr | nosemi)?;

nextexprseq
  ::= nextassignment (semiexpr | nosemi)?
  ;

nosemi ::= nextexprseq | jump;

semiexpr
  ::= ';' (exprseq | jump)
  ;

jump
  ::= (RETURN | BREAK | CONTINUE | ERROR | COMPILE_INTRINSIC | COMPILE_ERROR) rawseq?
  ;

nextassignment
  ::= nextinfix ('=' assignment)?
  ;

assignment
  ::= infix ('=' assignment)?
  ;

nextinfix
  ::= nextterm (binop | isop | (AS type))*
  ;

infix
  ::= term (binop | isop | (AS type))*
  ;

isop
  ::= (IS | ISNT) term
  ;

binop
  ::= (AND | OR | XOR | '+' | '-' | '*' | '/' | '%' | '%%' | '+~' | '-~' | '*~' | '/~' | '%~' | '%%~' | '<<' | '>>' | '<<~' | '>>~' | '==' | '!=' | '<' | '<=' | '>=' | '>' | '==~' | '!=~' | '<~' | '<=~' | '>=~' | '>~') '?'? term
  ;

nextterm ::=
  IF ('\' ID (',' ID)* '\')? rawseq THEN rawseq (elseif | (ELSE annotatedrawseq))? END
  | IFDEF ('\' ID (',' ID)* '\')? infix THEN rawseq (elseifdef | (ELSE annotatedrawseq))? END
  | IFTYPE ('\' ID (',' ID)* '\')? iftype (elseiftype | (ELSE annotatedrawseq))? END
  | MATCH ('\' ID (',' ID)* '\')? rawseq caseexpr* (ELSE annotatedrawseq)? END
  | WHILE ('\' ID (',' ID)* '\')? rawseq DO rawseq (ELSE annotatedrawseq)? END
  | REPEAT ('\' ID (',' ID)* '\')? rawseq UNTIL annotatedrawseq (ELSE annotatedrawseq)? END
  | FOR ('\' ID (',' ID)* '\')? idseq IN rawseq DO rawseq (ELSE annotatedrawseq)? END
  | WITH ('\' ID (',' ID)* '\')? (withelem (',' withelem)*) DO rawseq (ELSE annotatedrawseq)? END
  | TRY ('\' ID (',' ID)* '\')? rawseq (ELSE annotatedrawseq)? (THEN annotatedrawseq)? END
  | RECOVER ('\' ID (',' ID)* '\')? cap? rawseq END
  | CONSUME cap? term
  | nextpattern
  | HASH postfix
  ;

term ::=
  IF ('\' ID (',' ID)* '\')? rawseq THEN rawseq (elseif | (ELSE annotatedrawseq))? END
  | IFDEF ('\' ID (',' ID)* '\')? infix THEN rawseq (elseifdef | (ELSE annotatedrawseq))? END
  | IFTYPE ('\' ID (',' ID)* '\')? iftype (elseiftype | (ELSE annotatedrawseq))? END
  | MATCH ('\' ID (',' ID)* '\')? rawseq caseexpr* (ELSE annotatedrawseq)? END
  | WHILE ('\' ID (',' ID)* '\')? rawseq DO rawseq (ELSE annotatedrawseq)? END
  | REPEAT ('\' ID (',' ID)* '\')? rawseq UNTIL annotatedrawseq (ELSE annotatedrawseq)? END
  | FOR ('\' ID (',' ID)* '\')? idseq IN rawseq DO rawseq (ELSE annotatedrawseq)? END
  | WITH ('\' ID (',' ID)* '\')? (withelem (',' withelem)*) DO rawseq (ELSE annotatedrawseq)? END
  | TRY ('\' ID (',' ID)* '\')? rawseq (ELSE annotatedrawseq)? (THEN annotatedrawseq)? END
  | RECOVER ('\' ID (',' ID)* '\')? cap? rawseq END
  | CONSUME cap? term
  | pattern
  | HASH postfix
  ;

withelem
  ::= idseq '=' rawseq
  ;

caseexpr
  ::= '|' ('\' ID (',' ID)* '\')? pattern? (IF rawseq)? ('=>' rawseq)?
  ;

elseiftype
  ::= ELSEIF ('\' ID (',' ID)* '\')? iftype (elseiftype | (ELSE annotatedrawseq))?
  ;

iftype
  ::= type '<::=' type THEN rawseq
  ;

elseifdef
  ::= ELSEIF ('\' ID (',' ID)* '\')? infix THEN rawseq (elseifdef | (ELSE annotatedrawseq))?
  ;

elseif
  ::= ELSEIF ('\' ID (',' ID)* '\')? rawseq THEN rawseq (elseif | (ELSE annotatedrawseq))?
  ;

idseq
  ::= ID
  | ('(' | LPAREN_NEW) idseq_in_seq (',' idseq_in_seq)* ')'
  ;

idseq_in_seq
  ::= ID
  | ('(' | LPAREN_NEW) idseq_in_seq (',' idseq_in_seq)* ')'
  ;

nextpattern
  ::= (VAR | LET | EMBED) ID (':' type)?
  | nextparampattern
  ;

pattern
  ::= (VAR | LET | EMBED) ID (':' type)?
  | parampattern
  ;

nextparampattern
  ::= (NOT | ADDRESSOF | MINUS_NEW | MINUS_TILDE_NEW | DIGESTOF) parampattern
  | nextpostfix
  ;

parampattern
  ::= (NOT | ADDRESSOF | '-' | '-~' | MINUS_NEW | MINUS_TILDE_NEW | DIGESTOF) parampattern
  | postfix
  ;

nextpostfix
  ::= nextatom (dot | tilde | chain | typeargs | call)*
  ;

postfix
  ::= atom (dot | tilde | chain | typeargs | call)*
  ;

call
  ::= '(' positional? named? ')' '?'?
  ;

chain
  ::= '.>' ID
  ;

tilde
  ::= '~' ID
  ;

dot
  ::= '.' ID
  ;

nextatom
  ::= ID
  | THIS
  | literal
  | LPAREN_NEW rawseq tuple? ')'
  | LSQUARE_NEW ('as' type ':')? rawseq? ']'
  | 'object' ('\' ID (',' ID)* '\')? cap? ('is' type)? members 'end'
  | '{' ('\' ID (',' ID)* '\')? cap? ID? typeparams? ('(' | LPAREN_NEW) lambdaparams? ')' lambdacaptures? (':' type)? '?'? '=>' rawseq '}' cap?
  | '@{' ('\' ID (',' ID)* '\')? cap? ID? typeparams? ('(' | LPAREN_NEW) lambdaparams? ')' lambdacaptures? (':' type)? '?'? '=>' rawseq '}' cap?
  | ffi_decl typeargs? ('(' | LPAREN_NEW) positional? named? ')' '?'?
  | LOC
  ;

atom
  ::= ID
  | THIS
  | literal
  | ('(' | LPAREN_NEW) rawseq tuple? ')'
  | ('[' | LSQUARE_NEW) ('as' type ':')? rawseq? ']'
  | 'object' ('\' ID (',' ID)* '\')? cap? ('is' type)? members 'end'
  | '{' ('\' ID (',' ID)* '\')? cap? ID? typeparams? ('(' | LPAREN_NEW) lambdaparams? ')' lambdacaptures? (':' type)? '?'? '=>' rawseq '}' cap?
  | '@{' ('\' ID (',' ID)* '\')? cap? ID? typeparams? ('(' | LPAREN_NEW) lambdaparams? ')' lambdacaptures? (':' type)? '?'? '=>' rawseq '}' cap?
  | ffi_decl typeargs? ('(' | LPAREN_NEW) positional? named? ')' '?'?
  | LOC
  ;

tuple
  ::= ',' rawseq (',' rawseq)*
  ;

lambdacaptures
  ::= ('(' | LPAREN_NEW) (lambdacapture | THIS) (',' (lambdacapture | THIS))* ')'
  ;

lambdacapture
  ::= ID (':' type)? ('=' infix)?
  ;

lambdaparams
  ::= lambdaparam (',' lambdaparam)*
  ;

lambdaparam
  ::= ID (':' type)? ('=' infix)?
  ;

positional
  ::= rawseq (',' rawseq)*
  ;

named
  ::= WHERE namedarg (',' namedarg)*
  ;

namedarg
  ::= ID '=' rawseq
  ;

type
  ::= atomtype ('->' type)?
  ;

atomtype
  ::= THIS
  | cap
  | ('(' | LPAREN_NEW) infixtype tupletype? ')'
  | nominal
  | lambdatype
  | barelambdatype
  ;

barelambdatype
  ::= '@{' cap? ID? typeparams? ('(' | LPAREN_NEW) (type (',' type)*)? ')' (':' type)? '?'? '}' (cap | gencap)? ('^' | '!')?
  ;

lambdatype
  ::= '{' cap? ID? typeparams? ('(' | LPAREN_NEW) (type (',' type)*)? ')' (':' type)? '?'? '}' (cap | gencap)? ('^' | '!')?
  ;

tupletype
  ::= ',' infixtype (',' infixtype)*
  ;

infixtype
  ::= type (uniontype | isecttype)*
  ;

isecttype
  ::= '&' type
  ;

uniontype
  ::= '|' type
  ;

nominal
  ::= ID ('.' ID)? typeargs? (cap | gencap)? ('^' | '!')?
  ;

gencap
  ::= HASH_READ
  | HASH_SEND
  | HASH_SHARE
  | HASH_ALIAS
  | HASH_ANY
  ;

cap
  ::= ISO
  | TRN
  | REF
  | VAL
  | BOX
  | TAG
  ;

typeargs
  ::= '[' typearg (',' typearg)* ']'
  ;

typeparams
  ::= ('[' | LSQUARE_NEW) typeparam (',' typeparam)* ']'
  ;

params
  ::= (param | '...') (',' (param | '...'))*
  ;

typeparam
  ::= ID (':' type)? ('=' typearg)?
  ;

typearg
  ::= type
  | literal
  | HASH postfix
  ;

literal
  ::= TRUE
  | FALSE
  | NUMBER
  | FLOAT
  | STRING
  ;

param ::= ID ':' type ('=' infix)?;

ffi_decl ::= '@' (ID | STRING);

doc_string ::= STRING
